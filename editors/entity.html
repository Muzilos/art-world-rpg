<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Entity Editor</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0-beta3/css/all.min.css">
  <style>
    body {
      font-family: 'Inter', sans-serif;
    }

    canvas {
      background-color: #eee;
      display: block;
      border: 1px solid #ccc;
      border-radius: 0.5rem;
      /* Rounded corners for canvas */
    }

    .modal {
      position: fixed;
      z-index: 1000;
      left: 0;
      top: 0;
      width: 100%;
      height: 100%;
      background-color: rgba(0, 0, 0, 0.4);
      display: flex;
      justify-content: center;
      align-items: center;
    }

    .modal-content {
      background-color: #fefefe;
      padding: 20px;
      border-radius: 0.75rem;
      /* Rounded corners for modal */
      box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
      width: 90%;
      max-width: 400px;
      text-align: center;
      position: relative;
      /* For the close button */
    }

    .modal-content.prompt {
      max-width: 500px;
    }

    .modal-close-btn {
      position: absolute;
      top: 10px;
      right: 10px;
      background: none;
      border: none;
      font-size: 1.5rem;
      cursor: pointer;
      color: #718096;
    }

    .hidden {
      display: none !important;
    }

    textarea {
      resize: vertical;
    }

    /* Style for scrollable lists */
    .scrollable-list {
      max-height: 150px;
      overflow-y: auto;
      border: 1px solid #e2e8f0;
      border-radius: 0.375rem;
      padding: 0.5rem;
      background-color: #f7fafc;
    }
  </style>
</head>

<body class="min-h-screen bg-gray-100 p-4 font-inter text-gray-800">

  <div class="flex flex-col md:flex-row gap-4 h-full">

    <div class="flex-1 bg-white rounded-lg shadow-md p-4 flex flex-col">
      <h2 class="text-xl font-bold mb-4 text-purple-700">Map & Entity Placement</h2>
      <div class="mb-4">
        <label for="map-selector" class="block text-sm font-medium text-gray-700">Select Map:</label>
        <select id="map-selector"
          class="mt-1 block w-full pl-3 pr-10 py-2 text-base border-gray-300 focus:outline-none focus:ring-purple-500 focus:border-purple-500 sm:text-sm rounded-md">
        </select>
      </div>
      <div
        class="relative w-full overflow-auto rounded-md shadow-inner bg-gray-50 flex-grow flex items-center justify-center">
        <canvas id="gameCanvas" class="border border-gray-300"></canvas>
      </div>

      <div class="mt-4 bg-gray-50 p-3 rounded-md border border-gray-200">
        <h3 class="text-lg font-semibold mb-2">Entities on TOWN</h3>
        <div id="entity-list" class="flex flex-wrap gap-2 mb-3 scrollable-list">
        </div>
        <div class="flex gap-2">
          <button id="add-entity-btn"
            class="flex-1 bg-green-500 text-white py-2 px-4 rounded-md shadow hover:bg-green-600 transition-colors duration-200">
            <i class="fas fa-plus mr-2"></i>Add Entity
          </button>
          <button id="delete-entity-btn"
            class="flex-1 bg-red-500 text-white py-2 px-4 rounded-md shadow hover:bg-red-600 transition-colors duration-200 disabled:opacity-50 disabled:cursor-not-allowed">
            <i class="fas fa-trash-alt mr-2"></i>Delete Entity
          </button>
        </div>
      </div>
    </div>

    <div class="flex-1 bg-white rounded-lg shadow-md p-4 flex flex-col">
      <h2 class="text-xl font-bold mb-4 text-purple-700">Entity Details & Dialogue</h2>
      <p id="no-entity-selected-message" class="text-gray-600">Select a entity on the map or from the list to edit
        its details and dialogue.</p>

      <div id="entity-details-panel" class="flex-grow flex-col hidden">
        <div class="mb-4 p-3 bg-blue-50 rounded-md border border-blue-200">
          <h3 class="text-lg font-semibold mb-2 text-blue-800">Editing: <span id="editing-entity-id"></span></h3>
          <div class="grid grid-cols-2 gap-2">
            <div>
              <label class="block text-sm font-medium text-gray-700">ID:</label>
              <input type="text" id="entity-id-input" name="id"
                class="mt-1 block w-full border-gray-300 rounded-md shadow-sm focus:ring-purple-500 focus:border-purple-500 sm:text-sm"
                disabled />
            </div>
            <div>
              <label class="block text-sm font-medium text-gray-700">X Position:</label>
              <input type="number" id="entity-x-input" name="x"
                class="mt-1 block w-full border-gray-300 rounded-md shadow-sm focus:ring-purple-500 focus:border-purple-500 sm:text-sm" />
            </div>
            <div>
              <label class="block text-sm font-medium text-gray-700">Y Position:</label>
              <input type="number" id="entity-y-input" name="y"
                class="mt-1 block w-full border-gray-300 rounded-md shadow-sm focus:ring-purple-500 focus:border-purple-500 sm:text-sm" />
            </div>
          </div>
        </div>

        <div class="flex-grow flex flex-col bg-gray-50 p-3 rounded-md border border-gray-200 mt-4">
          <h3 class="text-lg font-semibold mb-2">Dialogue Tree</h3>
          <div class="mb-3">
            <label for="dialogue-state-select" class="block text-sm font-medium text-gray-700">Select Dialogue
              State:</label>
            <select id="dialogue-state-select"
              class="mt-1 block w-full pl-3 pr-10 py-2 text-base border-gray-300 focus:outline-none focus:ring-purple-500 focus:border-purple-500 sm:text-sm rounded-md">
            </select>
          </div>
          <div class="flex gap-2 mb-3">
            <button id="add-dialogue-state-btn"
              class="flex-1 bg-blue-500 text-white py-2 px-4 rounded-md shadow hover:bg-blue-600 transition-colors duration-200">
              <i class="fas fa-plus mr-2"></i>Add State
            </button>
            <button id="delete-dialogue-state-btn"
              class="flex-1 bg-red-500 text-white py-2 px-4 rounded-md shadow hover:bg-red-600 transition-colors duration-200 disabled:opacity-50 disabled:cursor-not-allowed">
              <i class="fas fa-trash-alt mr-2"></i>Delete State
            </button>
          </div>

          <div id="dialogue-state-content" class="hidden">
            <div class="mb-4">
              <label class="block text-sm font-medium text-gray-700">Dialogue Text:</label>
              <textarea id="dialogue-text-input" rows="3"
                class="mt-1 block w-full border-gray-300 rounded-md shadow-sm focus:ring-purple-500 focus:border-purple-500 sm:text-sm"></textarea>
              <button id="test-dialogue-btn"
                class="mt-2 bg-purple-500 text-white py-1 px-3 rounded-md text-sm hover:bg-purple-600 transition-colors duration-200">
                <i class="fas fa-play mr-2"></i>Test Dialogue
              </button>
            </div>

            <div class="flex-grow flex-col">
              <h4 class="text-md font-semibold mb-2">Dialogue Options:</h4>
              <div id="dialogue-options-list" class="flex flex-wrap gap-2 mb-3 scrollable-list">
              </div>
              <button id="add-dialogue-option-btn"
                class="mb-3 bg-blue-500 text-white py-2 px-4 rounded-md shadow hover:bg-blue-600 transition-colors duration-200">
                <i class="fas fa-plus mr-2"></i>Add Option
              </button>

              <div id="dialogue-option-content"
                class="p-3 bg-yellow-50 rounded-md border border-yellow-200 flex-grow hidden">
                <h5 class="text-md font-semibold mb-2 text-yellow-800">Editing Option <span
                    id="editing-option-index"></span></h5>
                <div class="mb-2">
                  <label class="block text-sm font-medium text-gray-700">Option Text:</label>
                  <input type="text" id="option-text-input" name="text"
                    class="mt-1 block w-full border-gray-300 rounded-md shadow-sm focus:ring-purple-500 focus:border-purple-500 sm:text-sm" />
                </div>
                <div class="mb-2">
                  <label class="block text-sm font-medium text-gray-700">Next State ID:</label>
                  <input type="text" id="option-next-state-input" name="nextState"
                    class="mt-1 block w-full border-gray-300 rounded-md shadow-sm focus:ring-purple-500 focus:border-purple-500 sm:text-sm" />
                </div>

                <h6 class="text-sm font-semibold mb-2 mt-4 text-gray-700">Actions:</h6>
                <div id="actions-list" class="mb-2 scrollable-list">
                </div>
                <button id="add-action-to-option-btn"
                  class="mb-3 bg-indigo-500 text-white py-1 px-3 rounded-md text-sm shadow hover:bg-indigo-600 transition-colors duration-200">
                  <i class="fas fa-plus mr-2"></i>Add Action
                </button>

                <div id="action-parameters-section"
                  class="p-3 bg-purple-50 rounded-md border border-purple-200 flex-grow hidden mt-4">
                  <h6 class="text-md font-semibold mb-2 text-purple-800">Editing Action <span
                      id="editing-action-index"></span></h6>
                  <div class="mb-2">
                    <label class="block text-sm font-medium text-gray-700">Action Type:</label>
                    <select id="action-type-select"
                      class="mt-1 block w-full pl-3 pr-10 py-2 text-base border-gray-300 focus:outline-none focus:ring-purple-500 focus:border-purple-500 sm:text-sm rounded-md">
                    </select>
                  </div>
                  <div id="action-parameters" class="mb-2 p-2 border border-gray-300 rounded-md bg-gray-100 hidden">
                  </div>
                  <button id="test-action-btn"
                    class="mt-2 bg-green-500 text-white py-1 px-3 rounded-md text-sm hover:bg-green-600 transition-colors duration-200">
                    <i class="fas fa-flask mr-2"></i>Test Action
                  </button>
                </div>


                <button id="delete-option-btn"
                  class="bg-red-500 text-white py-1 px-3 rounded-md text-sm shadow hover:bg-red-600 transition-colors duration-200 ml-2">
                  <i class="fas fa-trash-alt mr-2"></i>Delete Option
                </button>
              </div>
            </div>
          </div>
        </div>
      </div>
    </div>

    <div class="flex-1 bg-white rounded-lg shadow-md p-4 flex flex-col mt-4 md:mt-0">
      <h2 class="text-xl font-bold mb-4 text-purple-700">Game State & Quests</h2>
      <div class="flex-grow bg-gray-50 p-3 rounded-md border border-gray-200 mb-4">
        <h3 class="text-lg font-semibold mb-2">Current Quests</h3>
        <div id="quests-list" class="mb-3 scrollable-list">
        </div>
        <div class="mt-3 flex gap-2">
          <button id="add-quest-btn"
            class="flex-1 bg-blue-500 text-white py-2 px-4 rounded-md shadow hover:bg-blue-600 transition-colors duration-200">
            <i class="fas fa-plus mr-2"></i>Add New Quest
          </button>
        </div>
      </div>

      <div class="bg-gray-50 p-3 rounded-md border border-gray-200">
        <h3 class="text-lg font-bold mb-2">Export Data</h3>
        <p class="text-sm text-gray-700 mb-2">
          Copy the generated JavaScript for `entities.js` and `state.js` below to integrate into your game.
          Functions in `entities.js` will be re-converted to their original format.
          <script src="../js/entities.js"></script>
          <script src="../js/state.js"></script>
          <script src="../js/maps.js"></script>
        </p>
        <div class="mb-4">
          <label class="block text-sm font-medium text-gray-700">Exported `entities.js`:</label>
          <textarea id="exported-entities-output" rows="15" readOnly
            class="mt-1 block w-full border-gray-300 rounded-md shadow-sm font-mono text-xs bg-gray-100 resize-y"></textarea>
          <button id="copy-entities-btn"
            class="mt-2 bg-purple-500 text-white py-2 px-4 rounded-md shadow hover:bg-purple-600 transition-colors duration-200">
            <i class="fas fa-copy mr-2"></i>Copy entities.js
          </button>
        </div>
        <div>
          <label class="block text-sm font-medium text-gray-700">Exported `state.js` (Quests only):</label>
          <textarea id="exported-state-output" rows="5" readOnly
            class="mt-1 block w-full border-gray-300 rounded-md shadow-sm font-mono text-xs bg-gray-100 resize-y"></textarea>
          <button id="copy-state-btn"
            class="mt-2 bg-purple-500 text-white py-2 px-4 rounded-md shadow hover:bg-purple-600 transition-colors duration-200">
            <i class="fas fa-copy mr-2"></i>Copy state.js Quests
          </button>
        </div>
      </div>
    </div>
  </div>

  <div id="custom-modal" class="modal hidden">
    <div class="modal-content">
      <button class="modal-close-btn" onclick="hideCustomModal()"><i class="fas fa-times"></i></button>
      <p id="modal-message" class="mb-4 text-lg"></p>
      <input type="text" id="modal-input"
        class="mt-1 block w-full border-gray-300 rounded-md shadow-sm focus:ring-purple-500 focus:border-purple-500 sm:text-sm hidden mb-4"
        placeholder="Enter value..." />
      <div class="flex justify-center gap-4">
        <button id="modal-confirm-btn"
          class="bg-blue-500 text-white py-2 px-4 rounded-md shadow hover:bg-blue-600 transition-colors duration-200">OK</button>
        <button id="modal-cancel-btn"
          class="bg-gray-300 text-gray-800 py-2 px-4 rounded-md shadow hover:bg-gray-400 transition-colors duration-200 hidden">Cancel</button>
      </div>
    </div>
  </div>

  <div id="dialogue-simulator-modal" class="modal hidden">
    <div class="modal-content prompt max-w-2xl text-left">
      <button class="modal-close-btn" onclick="hideDialogueSimulatorModal()"><i class="fas fa-times"></i></button>
      <h3 class="text-xl font-bold mb-4 text-purple-700">Dialogue Simulator</h3>
      <div class="mb-4">
        <p class="text-gray-700 mb-2"><span class="font-semibold" id="sim-char-name"></span>: <span
            id="sim-dialogue-text"></span></p>
        <div id="sim-dialogue-options" class="flex flex-col gap-2 mt-3">
        </div>
      </div>
      <div class="border-t border-gray-200 pt-3 mt-3">
        <h4 class="font-semibold text-gray-800 mb-2">Simulated Game State Changes:</h4>
        <pre id="sim-state-changes" class="bg-gray-100 p-2 rounded-md text-xs font-mono overflow-auto max-h-40"></pre>
      </div>
      <div class="flex justify-end mt-4">
        <button id="sim-reset-btn"
          class="bg-purple-500 text-white py-2 px-4 rounded-md shadow hover:bg-purple-600 transition-colors duration-200">
          <i class="fas fa-redo mr-2"></i>Reset Simulation
        </button>
      </div>
    </div>
  </div>

  <script>
    // Utility to generate a unique ID
    const generateUniqueId = (prefix = 'new_id') => {
      return `${prefix}_${Math.random().toString(36).substr(2, 9)}`;
    };

    // Utility to copy text to clipboard and show a temporary message
    function copyToClipboard(text, message) {
      const textarea = document.createElement('textarea');
      textarea.value = text;
      document.body.appendChild(textarea);
      textarea.select();
      try {
        document.execCommand('copy');
        showCustomModal(message, 'alert');
      } catch (err) {
        console.error('Failed to copy text: ', err);
        showCustomModal('Failed to copy text. Please copy manually.', 'alert');
      } finally {
        document.body.removeChild(textarea);
      }
    }


    // Custom Modal Implementation (replaces alert/confirm/prompt)
    let modalCallback = null;

    function showCustomModal(message, type, onConfirm = null, defaultValue = '') {
      const modal = document.getElementById('custom-modal');
      const modalMessage = document.getElementById('modal-message');
      const modalInput = document.getElementById('modal-input');
      const modalConfirmBtn = document.getElementById('modal-confirm-btn');
      const modalCancelBtn = document.getElementById('modal-cancel-btn');

      modalMessage.textContent = message;
      modalInput.value = defaultValue;
      modal.classList.remove('hidden');

      // Reset buttons visibility
      modalConfirmBtn.classList.remove('hidden');
      modalCancelBtn.classList.add('hidden'); // Hidden by default for alert/prompt

      // Set modal type specific behavior
      if (type === 'prompt') {
        modalInput.classList.remove('hidden');
        modalInput.focus();
        modalConfirmBtn.onclick = () => {
          handleModalConfirm(modalInput.value);
        };
        modalCancelBtn.classList.remove('hidden'); // Show cancel for prompt
        modalCancelBtn.onclick = () => {
          handleModalConfirm(null);
        }; // Return null on cancel
      } else if (type === 'confirm') {
        modalInput.classList.add('hidden');
        modalConfirmBtn.onclick = () => {
          handleModalConfirm(true);
        };
        modalCancelBtn.classList.remove('hidden');
        modalCancelBtn.onclick = () => {
          handleModalConfirm(false);
        };
      } else { // 'alert'
        modalInput.classList.add('hidden');
        modalConfirmBtn.onclick = hideCustomModal;
      }
      modalCallback = onConfirm; // Store the callback
    }

    function hideCustomModal() {
      document.getElementById('custom-modal').classList.add('hidden');
      document.getElementById('modal-input').classList.add('hidden'); // Hide input on close
      modalCallback = null;
    }

    function handleModalConfirm(result) {
      if (modalCallback) {
        modalCallback(result);
      }
      hideCustomModal();
    }

    // --- Dialogue Simulation Modal ---
    let simChar = null;
    let simDialogueState = null;
    let simulatedGameState = null;
    let simulatedEntities = null; // A deep copy of entities for simulation

    function showDialogueSimulatorModal() {
      const modal = document.getElementById('dialogue-simulator-modal');
      modal.classList.remove('hidden');
      // Initialize simulation with current editor data
      simulatedGameState = JSON.parse(JSON.stringify(gameState));
      simulatedEntities = JSON.parse(JSON.stringify(entities)); // Need full chars for actions that remove chars

      const currentSelectedChar = getSelectedEntity();
      const currentSelectedStateId = selectedDialogueState;

      if (currentSelectedChar && currentSelectedStateId) {
        simChar = JSON.parse(JSON.stringify(currentSelectedChar)); // Deep copy for simulation
        simDialogueState = currentSelectedStateId;
        renderSimulationDialogue();
      } else {
        document.getElementById('sim-dialogue-text').textContent = "No entity or dialogue state selected to simulate.";
        document.getElementById('sim-dialogue-options').innerHTML = '';
      }
      document.getElementById('sim-state-changes').textContent = JSON.stringify(simulatedGameState, null, 2);
    }

    function hideDialogueSimulatorModal() {
      document.getElementById('dialogue-simulator-modal').classList.add('hidden');
      simChar = null;
      simDialogueState = null;
      simulatedGameState = null;
      simulatedEntities = null;
    }

    // This is the showDialogue for the simulation environment
    function showDialogue(charObj, stateKey) {
      simChar = charObj;
      simDialogueState = stateKey;
      renderSimulationDialogue();
    }

    function renderSimulationDialogue() {
      if (!simChar || !simDialogueState) {
        document.getElementById('sim-dialogue-text').textContent = "End of dialogue or invalid state.";
        document.getElementById('sim-dialogue-options').innerHTML = '';
        document.getElementById('sim-char-name').textContent = '';
        return;
      }

      const currentSimulatedDialogueState = simChar.dialogue[simDialogueState];

      if (!currentSimulatedDialogueState) {
        document.getElementById('sim-dialogue-text').textContent = "Error: Dialogue state not found.";
        document.getElementById('sim-dialogue-options').innerHTML = '';
        document.getElementById('sim-char-name').textContent = simChar.id;
        return;
      }

      document.getElementById('sim-char-name').textContent = simChar.id;
      document.getElementById('sim-dialogue-text').textContent = currentSimulatedDialogueState.text;

      const optionsDiv = document.getElementById('sim-dialogue-options');
      optionsDiv.innerHTML = '';

      if (currentSimulatedDialogueState.options && currentSimulatedDialogueState.options.length > 0) {
        currentSimulatedDialogueState.options.forEach((option, index) => {
          const button = document.createElement('button');
          button.className = 'bg-gray-200 hover:bg-gray-300 text-gray-800 font-semibold py-2 px-4 rounded-md shadow transition-colors duration-200 text-left';
          button.textContent = option.text;
          button.onclick = () => {
            // Execute actions for this option in the simulated environment
            if (option.actions) {
              option.actions.forEach(actionObj => {
                // Ensure actionObj is not null/undefined before proceeding
                if (!actionObj) {
                  console.warn("Skipping null/undefined actionObj in simulation.");
                  return;
                }

                const actionDef = gameActionMetadata[actionObj.id];
                if (actionDef) {
                  try {
                    if (actionObj.id === 'customAction') {
                      // For custom actions, parse and execute the raw code directly
                      // The custom action function expects (gameState, entities) as arguments
                      const func = new Function('gameState', 'entities', actionObj.params.code);
                      func(simulatedGameState, simulatedEntities);
                    } else if (actionObj.id === 'none') {
                      // Do nothing for 'none' action
                      return;
                    } else {
                      // Get the actual factory function from the gameActions object
                      const actionFunctionCreator = gameActions[actionObj.id];

                      if (typeof actionFunctionCreator === 'function') {
                        // Map parameters to arguments
                        const orderedParams = actionDef.parameters.map(param => actionObj.params[param.name]);
                        // Call the factory function (e.g., gameActions.addItemToBackpack('item'))
                        const executableAction = actionFunctionCreator(...orderedParams);
                        // Then execute the returned function, passing simulated state and entities
                        if (typeof executableAction === 'function') {
                          executableAction(simulatedGameState, simulatedEntities);
                        } else {
                          console.warn(`Simulation Warning: Action '${actionObj.id}' did not return an executable function.`);
                        }
                      } else {
                        console.warn(`Simulation Warning: Action function '${actionObj.id}' not found in gameActions.`);
                      }
                    }
                  } catch (e) {
                    console.error("Simulation Action Error:", e);
                    // Use the simulation modal's showDialogue for errors within simulation
                    showDialogue({
                      id: 'SYSTEM',
                      dialogue: {
                        'error_sim_action': {
                          text: `Simulation error: ${e.message}`,
                          options: [{
                            text: "Continue",
                            nextState: 'end'
                          }]
                        }
                      }
                    }, 'error_sim_action');
                  }
                }
              });
            }

            // Transition to next state
            const nextStateId = option.nextState;
            if (simChar.dialogue[nextStateId]) {
              simDialogueState = nextStateId;
            } else {
              simDialogueState = 'end'; // Or some default end state if nextState is invalid
            }
            renderSimulationDialogue();
            document.getElementById('sim-state-changes').textContent = JSON.stringify(simulatedGameState.quests, null, 2); // Show only quests for brevity
          };
          optionsDiv.appendChild(button);
        });
      } else {
        // If no options, the dialogue ends or needs a 'return' button
        const endMessage = document.createElement('p');
        endMessage.className = 'text-gray-500 italic';
        endMessage.textContent = "(End of dialogue)";
        optionsDiv.appendChild(endMessage);
      }
    }

    // Reset Simulation
    document.getElementById('sim-reset-btn').addEventListener('click', () => {
      simulatedGameState = JSON.parse(JSON.stringify(gameState));
      simulatedEntities = JSON.parse(JSON.stringify(entities)); // Reset entities too

      // Re-initialize simChar and simDialogueState based on the editor's current selection
      const currentSelectedChar = getSelectedEntity();
      const currentSelectedStateId = selectedDialogueState;

      if (currentSelectedChar && currentSelectedStateId) {
        simChar = JSON.parse(JSON.stringify(currentSelectedChar)); // Deep copy for simulation
        simDialogueState = currentSelectedStateId;
        renderSimulationDialogue(); // Re-render the simulation UI with reset state
      } else {
        // If no entity selected in editor, clear simulator
        simChar = null;
        simDialogueState = null;
        document.getElementById('sim-dialogue-text').textContent = "No entity or dialogue state selected to simulate.";
        document.getElementById('sim-dialogue-options').innerHTML = '';
        document.getElementById('sim-char-name').textContent = '';
      }
      document.getElementById('sim-state-changes').textContent = JSON.stringify(simulatedGameState.quests, null, 2); // Update state display
    });

    let currentMapId = 'town';
    let selectedEntity = null; // { mapId, charId }
    let selectedDialogueState = null; // string (state ID)
    let selectedDialogueOptionIndex = null; // number (index of option in options array)
    let selectedActionIndex = null; // index of action within selected dialogue option's actions array

    // DOM Elements (cached for performance)
    let canvas, ctx;
    let charListDiv, addCharBtn, deleteCharBtn;
    let noCharSelectedMsg, charDetailsPanel;
    let editingCharIdSpan, charXInput, charYInput;
    let dialogueStateSelect, addDialogueStateBtn, deleteDialogueStateBtn, dialogueStateContentDiv;
    let dialogueTextInput, testDialogueBtn;
    let dialogueOptionsList, addDialogueOptionBtn;
    let dialogueOptionContentDiv, editingOptionIndexSpan, optionTextInput, optionNextStateInput;
    let actionsListDiv, addActionToOptionBtn, deleteOptionBtn; // Renamed action related elements
    let actionParametersSectionDiv, editingActionIndexSpan, actionTypeSelect, actionParametersDiv, testActionBtn; // Elements for individual action editing

    let questsListDiv, addQuestBtn;
    let exportedEntitiesOutput, copyEntitiesBtn, exportedStateOutput, copyStateBtn;

    // Initialization: No longer transforming gameActions. Direct use of structured data.
    function initializeEditorData() {
      // No complex transformation needed, as `entities` is already in the desired structured format.
      // The `entities` object loaded should already have actions as `{ id, params }`
      // If you were loading from a simpler format, this is where conversion would happen.
    }


    // Drawing function for the map and entities
    const drawMap = () => {
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      const currentMap = maps[currentMapId];
      if (!currentMap) return;

      canvas.width = currentMap.width * TILE_SIZE;
      canvas.height = currentMap.height * TILE_SIZE;

      // Draw tiles
      for (let y = 0; y < currentMap.height; y++) {
        for (let x = 0; x < currentMap.width; x++) {
          const tileType = currentMap.tiles[y * currentMap.width + x];
          ctx.fillStyle = tileColors[tileType] || '#ffffff';
          ctx.fillRect(x * TILE_SIZE, y * TILE_SIZE, TILE_SIZE, TILE_SIZE);
          ctx.strokeStyle = '#333';
          ctx.strokeRect(x * TILE_SIZE, y * TILE_SIZE, TILE_SIZE, TILE_SIZE);
        }
      }

      // Draw entities
      const charsOnMap = maps[currentMapId].entities || [];
      charsOnMap.forEach(char => {
        const isSelected = selectedEntity && selectedEntity.mapId === currentMapId && selectedEntity.charId === char.id;
        ctx.fillStyle = isSelected ? 'rgba(255, 255, 0, 0.7)' : 'rgba(0, 0, 0, 0.7)'; // Yellow for selected, black for others
        ctx.beginPath();
        ctx.arc(char.x * TILE_SIZE + TILE_SIZE / 2, char.y * TILE_SIZE + TILE_SIZE / 2, TILE_SIZE / 3, 0, Math.PI * 2);
        ctx.fill();
        ctx.fillStyle = 'white';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.font = '10px Arial';
        ctx.fillText(char.id.substring(0, 3).toUpperCase(), char.x * TILE_SIZE + TILE_SIZE / 2, char.y * TILE_SIZE + TILE_SIZE / 2);
        if (isSelected) {
          ctx.strokeStyle = 'red';
          ctx.lineWidth = 2;
          ctx.stroke();
        }
      });
    };

    // --- UI Rendering Functions ---

    const renderMapSelector = () => {
      const mapSelector = document.getElementById('map-selector');
      mapSelector.innerHTML = ''; // Clear existing options
      Object.keys(maps).forEach(mapId => {
        const option = document.createElement('option');
        option.value = mapId;
        option.textContent = maps[mapId].name || mapId;
        if (mapId === currentMapId) {
          option.selected = true;
        }
        mapSelector.appendChild(option);
      });
      mapSelector.addEventListener('change', (e) => {
        handleMapChange(e.target.value);
      });
    };

    const renderEntityList = () => {
      charListDiv.innerHTML = ''; // Clear existing buttons
      const charsOnMap = entities[currentMapId] || [];
      if (charsOnMap.length === 0) {
        charListDiv.innerHTML = '<p class="text-gray-500 italic">No entities on this map.</p>';
      }
      charsOnMap.forEach(char => {
        const button = document.createElement('button');
        button.className = `px-3 py-1 rounded-md text-sm font-medium transition-colors duration-200 ${selectedEntity && selectedEntity.charId === char.id ?
          'bg-purple-600 text-white shadow-lg' :
          'bg-gray-200 text-gray-800 hover:bg-purple-100 hover:text-purple-700'
          }`;
        button.textContent = `${char.id} (X:${char.x}, Y:${char.y})`;
        button.onclick = () => {
          selectedEntity = {
            mapId: currentMapId,
            charId: char.id
          };
          selectedDialogueState = Object.keys(char.dialogue)[0] || null;
          selectedDialogueOptionIndex = null;
          selectedActionIndex = null; // Clear action selection
          renderAllUI(); // Re-render everything on selection
        };
        charListDiv.appendChild(button);
      });
      deleteCharBtn.disabled = !selectedEntity;
    };

    const renderEntityDetails = () => {
      if (!selectedEntity) {
        noCharSelectedMsg.classList.remove('hidden');
        charDetailsPanel.classList.add('hidden');
        return;
      }

      noCharSelectedMsg.classList.add('hidden');
      charDetailsPanel.classList.remove('hidden');

      const currentSelectedChar = entities[selectedEntity.mapId]?.find(c => c.id === selectedEntity.charId);
      if (!currentSelectedChar) {
        selectedEntity = null; // Clear selection if entity not found
        renderAllUI();
        return;
      }

      editingCharIdSpan.textContent = currentSelectedChar.id;
      charXInput.value = currentSelectedChar.x;
      charYInput.value = currentSelectedChar.y;

      // Populate dialogue state dropdown
      dialogueStateSelect.innerHTML = '';
      const dialogueStateKeys = Object.keys(currentSelectedChar.dialogue);
      if (dialogueStateKeys.length === 0) {
        selectedDialogueState = null;
        dialogueStateSelect.innerHTML = '<option value="" disabled>No states</option>';
      } else {
        dialogueStateKeys.forEach(stateId => {
          const option = document.createElement('option');
          option.value = stateId;
          option.textContent = stateId;
          dialogueStateSelect.appendChild(option);
        });
        if (!selectedDialogueState || !currentSelectedChar.dialogue[selectedDialogueState]) {
          selectedDialogueState = dialogueStateKeys[0]; // Default to first state if none selected or invalid
        }
      }
      dialogueStateSelect.value = selectedDialogueState || '';

      renderDialogueEditor();
    };

    const renderDialogueEditor = () => {
      const currentSelectedChar = selectedEntity ? entities[selectedEntity.mapId]?.find(c => c.id === selectedEntity.charId) : null;
      if (!currentSelectedChar || !selectedDialogueState) {
        dialogueStateContentDiv.classList.add('hidden');
        deleteDialogueStateBtn.disabled = true;
        return;
      }

      dialogueStateContentDiv.classList.remove('hidden');
      deleteDialogueStateBtn.disabled = false;

      const currentDialogueState = currentSelectedChar.dialogue[selectedDialogueState];
      dialogueTextInput.value = currentDialogueState.text;

      // Render dialogue options buttons
      dialogueOptionsList.innerHTML = '';
      if (currentDialogueState.options && currentDialogueState.options.length === 0) {
        dialogueOptionsList.innerHTML = '<p class="text-gray-500 italic">No options for this state.</p>';
        selectedDialogueOptionIndex = null;
      } else {
        (currentDialogueState.options || []).forEach((option, index) => {
          const button = document.createElement('button');
          button.className = `px-3 py-1 rounded-md text-sm font-medium transition-colors duration-200 ${selectedDialogueOptionIndex === index ?
            'bg-indigo-600 text-white shadow-lg' :
            'bg-gray-200 text-gray-800 hover:bg-indigo-100 hover:text-indigo-700'
            }`;
          button.textContent = `${option.text.substring(0, 20)}${option.text.length > 20 ? '...' : ''}`;
          button.onclick = () => {
            selectedDialogueOptionIndex = index;
            selectedActionIndex = null; // Clear action selection when new option is selected
            renderDialogueEditor(); // Re-render to show option details
          };
          dialogueOptionsList.appendChild(button);
        });
      }

      renderDialogueOptionDetails();
    };

    const renderDialogueOptionDetails = () => {
      const currentSelectedChar = selectedEntity ? entities[selectedEntity.mapId]?.find(c => c.id === selectedEntity.charId) : null;
      const currentDialogueState = currentSelectedChar && selectedDialogueState ? currentSelectedChar.dialogue[selectedDialogueState] : null;
      const currentDialogueOption = currentDialogueState && selectedDialogueOptionIndex !== null ? currentDialogueState.options[selectedDialogueOptionIndex] : null;

      if (!currentDialogueOption) {
        dialogueOptionContentDiv.classList.add('hidden');
        deleteOptionBtn.disabled = true;
        return;
      }

      dialogueOptionContentDiv.classList.remove('hidden');
      deleteOptionBtn.disabled = false;
      editingOptionIndexSpan.textContent = selectedDialogueOptionIndex + 1;
      optionTextInput.value = currentDialogueOption.text;
      optionNextStateInput.value = currentDialogueOption.nextState;

      // Render actions for this option
      actionsListDiv.innerHTML = '';
      if (currentDialogueOption.actions && currentDialogueOption.actions.length === 0) {
        actionsListDiv.innerHTML = '<p class="text-gray-500 italic">No actions for this option.</p>';
        selectedActionIndex = null;
      } else {
        currentDialogueOption.actions.forEach((actionObj, index) => {
          // Ensure actionObj is not null/undefined
          if (!actionObj) {
            console.warn("Skipping null/undefined actionObj in renderDialogueOptionDetails.");
            return;
          }

          const actionDef = gameActionMetadata[actionObj.id];
          const actionName = actionDef ? actionDef.name : 'Unknown Action';

          const actionItemDiv = document.createElement('div');
          actionItemDiv.className = `flex items-center gap-2 mb-2 p-2 rounded-md border ${selectedActionIndex === index ? 'bg-blue-100 border-blue-300' : 'bg-gray-100 border-gray-200'}`;

          const button = document.createElement('button');
          button.className = `flex-grow text-left px-2 py-1 rounded-md text-sm transition-colors duration-200 ${selectedActionIndex === index ? 'text-blue-800 font-semibold' : 'text-gray-700 hover:bg-gray-200'
            }`;
          button.textContent = `Action ${index + 1}: ${actionName}`;
          button.onclick = () => {
            selectedActionIndex = index;
            renderDialogueOptionDetails(); // Re-render to show action parameters
          };
          actionItemDiv.appendChild(button);

          const deleteActionButton = document.createElement('button');
          deleteActionButton.className = 'text-red-500 hover:text-red-700 px-2 py-1 rounded-full text-lg';
          deleteActionButton.innerHTML = '<i class="fas fa-minus-circle"></i>';
          deleteActionButton.title = `Delete Action ${index + 1}`;
          deleteActionButton.onclick = () => {
            showCustomModal(`Are you sure you want to delete Action ${index + 1}?`, 'confirm', (result) => {
              if (result) {
                currentDialogueOption.actions.splice(index, 1);
                selectedActionIndex = null; // Clear selection after deletion
                renderDialogueOptionDetails();
              }
            });
          };
          actionItemDiv.appendChild(deleteActionButton);
          actionsListDiv.appendChild(actionItemDiv);
        });
      }

      renderActionParametersSection();
    };

    const renderActionParametersSection = () => {
      const currentDialogueOption = getSelectedDialogueOption();
      const currentAction = currentDialogueOption && selectedActionIndex !== null ? currentDialogueOption.actions[selectedActionIndex] : null;
      const skillOptions = gameActionMetadata.gainXp.parameters.find(p => p.name === 'skills').options;

      actionParametersSectionDiv.classList.add('hidden'); // Hide the entire section by default
      actionParametersDiv.innerHTML = ''; // Clear previous parameters
      actionParametersDiv.classList.add('hidden'); // Hide inner parameters div

      if (!currentAction) {
        // No action selected, hide parameters section
        return;
      }

      const selectedActionDef = gameActionMetadata[currentAction.id];

      if (selectedActionDef) {
        actionParametersSectionDiv.classList.remove('hidden'); // Show the whole section
        editingActionIndexSpan.textContent = selectedActionIndex + 1;

        // Populate action type select
        actionTypeSelect.innerHTML = '';
        Object.keys(gameActionMetadata).forEach(actionId => {
          const actionMeta = gameActionMetadata[actionId];
          const optionElem = document.createElement('option');
          optionElem.value = actionId;
          optionElem.textContent = actionMeta.name;
          actionTypeSelect.appendChild(optionElem);
        });
        actionTypeSelect.value = currentAction.id;

        if (selectedActionDef.parameters.length > 0) {
          actionParametersDiv.classList.remove('hidden'); // Show inner parameters div
          // Render specific parameters for the selected action type
          selectedActionDef.parameters.forEach(param => {
            const paramDiv = document.createElement('div');
            paramDiv.className = 'mb-2';

            const label = document.createElement('label');
            label.className = 'block text-sm font-medium text-gray-700';
            label.textContent = param.label + ':';
            paramDiv.appendChild(label);

            if (currentAction.id === 'gainXp' && (param.name === 'amounts' || param.name === 'skills')) {
              // Special handling for gainXp to allow multiple entries
              const containerDiv = document.createElement('div');
              containerDiv.className = 'flex flex-col gap-2 p-2 border border-gray-300 rounded-md bg-gray-50';
              containerDiv.id = `gain-xp-${param.name}-list`;

              // Ensure arrays exist for params
              if (!currentAction.params.amounts) currentAction.params.amounts = [];
              if (!currentAction.params.skills) currentAction.params.skills = [];

              // Render existing amount/skill pairs
              for (let i = 0; i < Math.max(currentAction.params.amounts.length, currentAction.params.skills.length); i++) {
                const entryDiv = document.createElement('div');
                entryDiv.className = 'flex items-center gap-2';

                // Amount input
                const amountInput = document.createElement('input');
                amountInput.type = 'number';
                amountInput.className = 'flex-1 mt-1 block w-full border-gray-300 rounded-md shadow-sm sm:text-sm';
                amountInput.placeholder = 'Amount';
                amountInput.value = currentAction.params.amounts[i] !== undefined ? currentAction.params.amounts[i] : (param.defaultValue !== undefined ? param.defaultValue : 0);
                amountInput.dataset.index = i;
                amountInput.addEventListener('input', (e) => {
                  const idx = parseInt(e.target.dataset.index);
                  currentAction.params.amounts[idx] = parseInt(e.target.value) || 0;
                  renderExportData();
                });
                entryDiv.appendChild(amountInput);

                // Skill select
                const skillSelect = document.createElement('select');
                skillSelect.className = 'flex-1 mt-1 block w-full pl-3 pr-10 py-2 text-base border-gray-300 rounded-md sm:text-sm';
                const skillOptions = typeof gameActionMetadata.gainXp.parameters.find(p => p.name === 'skills').options === 'function' ? gameActionMetadata.gainXp.parameters.find(p => p.name === 'skills').options() : gameActionMetadata.gainXp.parameters.find(p => p.name === 'skills').options;
                skillOptions.forEach(opt => {
                  const optionElem = document.createElement('option');
                  optionElem.value = opt;
                  optionElem.textContent = opt;
                  skillSelect.appendChild(optionElem);
                });
                skillSelect.value = currentAction.params.skills[i] !== undefined ? currentAction.params.skills[i] : (param.defaultValue !== undefined ? param.defaultValue : skillOptions[0] || '');
                skillSelect.dataset.index = i;
                skillSelect.addEventListener('change', (e) => {
                  const idx = parseInt(e.target.dataset.index);
                  currentAction.params.skills[idx] = e.target.value;
                  renderExportData();
                });
                entryDiv.appendChild(skillSelect);

                // Remove button
                const removeButton = document.createElement('button');
                removeButton.className = 'text-red-500 hover:text-red-700 px-2 py-1 rounded-full text-lg';
                removeButton.innerHTML = '<i class="fas fa-times-circle"></i>';
                removeButton.title = 'Remove XP Entry';
                removeButton.onclick = () => {
                  showCustomModal('Are you sure you want to remove this XP entry?', 'confirm', (result) => {
                    if (result) {
                      currentAction.params.amounts.splice(i, 1);
                      currentAction.params.skills.splice(i, 1);
                      renderActionParametersSection(); // Re-render the section
                    }
                  });
                };
                entryDiv.appendChild(removeButton);

                containerDiv.appendChild(entryDiv);
              }

              // Add new entry button
              const addButton = document.createElement('button');
              addButton.className = 'mt-2 bg-purple-400 text-white py-1 px-3 rounded-md text-sm hover:bg-purple-500 transition-colors duration-200';
              addButton.innerHTML = '<i class="fas fa-plus mr-1"></i>Add XP Entry';
              addButton.onclick = () => {
                currentAction.params.amounts.push(0); // Default amount
                currentAction.params.skills.push(skillOptions[0] || ''); // Default skill
                renderActionParametersSection(); // Re-render to show new input fields
              };
              containerDiv.appendChild(addButton);
              paramDiv.appendChild(containerDiv);

              // Add this paramDiv only once, for either 'amounts' or 'skills', not both.
              // We'll treat 'amounts' as the master for the UI group.
              if (param.name === 'amounts') {
                actionParametersDiv.appendChild(paramDiv);
              }
            } else {
              let inputElement;
              // Use currentAction.params for initial value
              let paramValue = currentAction.params[param.name];

              if (param.type === 'text' || param.type === 'number') {
                inputElement = document.createElement('input');
                inputElement.type = param.type;
                inputElement.className = 'mt-1 block w-full border-gray-300 rounded-md shadow-sm sm:text-sm';
                // Set value, respecting defaultValue if paramValue is undefined
                inputElement.value = paramValue !== undefined ? paramValue : (param.defaultValue !== undefined ? param.defaultValue : '');
              } else if (param.type === 'textarea') {
                inputElement = document.createElement('textarea');
                inputElement.rows = 5;
                inputElement.className = 'mt-1 block w-full border-gray-300 rounded-md shadow-sm font-mono text-xs';
                inputElement.value = paramValue !== undefined ? paramValue : (param.defaultValue !== undefined ? param.defaultValue : '');
              } else if (param.type === 'select') {
                inputElement = document.createElement('select');
                inputElement.className = 'mt-1 block w-full pl-3 pr-10 py-2 text-base border-gray-300 rounded-md sm:text-sm';
                // Dynamically get options if it's a function (e.g., for quest IDs)
                const options = typeof param.options === 'function' ? param.options() : param.options;
                options.forEach(opt => {
                  const optionElem = document.createElement('option');
                  optionElem.value = opt;
                  optionElem.textContent = opt;
                  inputElement.appendChild(optionElem);
                });
                // Set value, respecting defaultValue if paramValue is undefined
                inputElement.value = paramValue !== undefined ? paramValue : (param.defaultValue !== undefined ? param.defaultValue : options[0] || '');
              }

              inputElement.id = `action-param-${param.name}`;
              inputElement.name = param.name;
              inputElement.addEventListener('input', updateCurrentActionParameters); // Use input for text/textarea
              inputElement.addEventListener('change', updateCurrentActionParameters); // Use change for select/number
              paramDiv.appendChild(inputElement);
              actionParametersDiv.appendChild(paramDiv);

              // If a parameter has a default value and it's not set in currentAction.params, initialize it.
              if (param.defaultValue !== undefined && currentAction.params[param.name] === undefined) {
                currentAction.params[param.name] = param.defaultValue;
              }
            }
          });
        }
      }
    };

    const updateCurrentActionParameters = () => {
      const currentDialogueOption = getSelectedDialogueOption();
      if (!currentDialogueOption || selectedActionIndex === null) return;

      const currentAction = currentDialogueOption.actions[selectedActionIndex];
      const selectedActionDef = gameActionMetadata[actionTypeSelect.value];

      if (selectedActionDef) {
        // If action type changed via dropdown
        if (currentAction.id !== actionTypeSelect.value) {
          currentAction.id = actionTypeSelect.value;
          currentAction.params = {}; // Clear params when type changes
          // Re-populate with default values for new action type if they exist
          selectedActionDef.parameters.forEach(param => {
            if (param.defaultValue !== undefined) {
              currentAction.params[param.name] = param.defaultValue;
            }
          });
          renderActionParametersSection(); // Re-render parameters for new type
          return;
        }

        // Update individual parameters
        selectedActionDef.parameters.forEach(param => {
          if (currentAction.id === 'gainXp' && (param.name === 'amounts' || param.name === 'skills')) {
            // These are handled by their specific input listeners within renderActionParametersSection
            // No need to re-process here as they directly update currentAction.params.amounts/skills
            return;
          }
          const inputElement = document.getElementById(`action-param-${param.name}`);
          if (inputElement) {
            let value = inputElement.value;
            if (param.type === 'number') {
              value = parseInt(value);
              if (isNaN(value)) value = 0; // Ensure number is valid
            }
            currentAction.params[param.name] = value;
          }
        });
      }
      renderExportData(); // Re-render export data to reflect changes
    };


    const renderQuestEditor = () => {
      questsListDiv.innerHTML = '';
      const questIds = Object.keys(gameState.quests);
      if (questIds.length === 0) {
        questsListDiv.innerHTML = '<p class="text-gray-500 italic">No quests defined.</p>';
      }

      questIds.forEach(questId => {
        const questItemDiv = document.createElement('div');
        questItemDiv.className = 'flex items-center gap-2 mb-2 p-2 rounded-md bg-gray-100 border border-gray-200';

        const questNameSpan = document.createElement('span');
        questNameSpan.className = 'font-semibold text-gray-800 mr-2';
        questNameSpan.textContent = `${questId}:`;
        questItemDiv.appendChild(questNameSpan);

        const statusSelect = document.createElement('select');
        statusSelect.className = 'flex-grow px-2 py-1 rounded-md text-sm border border-gray-300';
        ['not_started', 'accepted', 'in_progress', 'completed', 'rewarded'].forEach(status => {
          const option = document.createElement('option');
          option.value = status;
          option.textContent = status.replace(/_/g, ' ').toUpperCase();
          statusSelect.appendChild(option);
        });
        statusSelect.value = gameState.quests[questId];
        statusSelect.addEventListener('change', (e) => {
          gameState.quests[questId] = e.target.value;
          renderExportData(); // Update export data on change
        });
        questItemDiv.appendChild(statusSelect);

        const deleteQuestButton = document.createElement('button');
        deleteQuestButton.className = 'text-red-500 hover:text-red-700 px-2 py-1 rounded-full text-lg';
        deleteQuestButton.innerHTML = '<i class="fas fa-trash-alt"></i>';
        deleteQuestButton.title = `Delete Quest: ${questId}`;
        deleteQuestButton.onclick = () => {
          showCustomModal(`Are you sure you want to delete quest "${questId}"?`, 'confirm', (result) => {
            if (result) {
              delete gameState.quests[questId];
              renderAllUI();
            }
          });
        };
        questItemDiv.appendChild(deleteQuestButton);
        questsListDiv.appendChild(questItemDiv);
      });
    };

    const renderExportData = () => {
      // This helper function generates a string representation of the action call
      // e.g., "gameActions.changeQuestState('chickenQuest', 'accepted')"
      const generateActionCallString = (actionObj) => {
        // Ensure actionObj is not null/undefined before proceeding
        if (!actionObj) {
          console.warn("Skipping null/undefined actionObj during action call string generation.");
          return null; // Return null to filter out
        }

        // Directly return the stringified action object in the desired format
        // This will now output: `{ id: 'changeQuestState', params: { questId: 'chickenQuest', newState: 'accepted' } }`
        return JSON.stringify(actionObj, (key, value) => {
          // Custom replacer function to handle specific formatting needs if any
          // For now, default stringify is fine. We just want the raw object.
          return value;
        }, 2); // Use 2 for indentation for readability
      };

      // Create a deep copy of entities for export to avoid modifying the live data
      const exportEntitiesResult = JSON.parse(JSON.stringify(entities));

      let entitiesString = 'const entities = {\n';
      const mapKeys = Object.keys(exportEntitiesResult);

      mapKeys.forEach((mapId, mapIndex) => {
        entitiesString += `  '${mapId}': [\n`;
        const charsOnMap = exportEntitiesResult[mapId];

        charsOnMap.forEach((char, charIndex) => {
          entitiesString += `    {\n`;
          entitiesString += `      id: '${char.id}',\n`;
          entitiesString += `      x: ${char.x},\n`;
          entitiesString += `      y: ${char.y},\n`;
          entitiesString += `      dialogue: {\n`;

          const dialogueStateKeys = Object.keys(char.dialogue);
          dialogueStateKeys.forEach((stateId, stateIndex) => {
            const state = char.dialogue[stateId];
            entitiesString += `        '${stateId}': {\n`;
            // Use backticks for text to handle multi-line strings easily
            entitiesString += `          text: \`${state.text.replace(/`/g, '\\`')}\`,\n`;
            entitiesString += `          options: [\n`;

            (state.options || []).forEach((option, optionIndex) => {
              entitiesString += `            {\n`;
              entitiesString += `              text: \`${option.text.replace(/`/g, '\\`')}\`,\n`;
              entitiesString += `              nextState: '${option.nextState}',\n`;

              const actionsForExport = (option.actions || [])
                .map(actionObj => generateActionCallString(actionObj))
                .filter(Boolean); // Filter out nulls/undefineds

              if (actionsForExport.length > 0) {
                // Join actions with comma and newline for proper formatting
                entitiesString += `              actions: [\n`;
                actionsForExport.forEach((actionStr, i) => {
                  entitiesString += `                ${actionStr}${i < actionsForExport.length - 1 ? ',' : ''}\n`;
                });
                entitiesString += `              ]\n`;
              }
              entitiesString += `            }${optionIndex < (state.options.length - 1) ? ',' : ''}\n`; // Comma after option
            });
            entitiesString += `          ]\n`; // Close options array
            entitiesString += `        }${stateIndex < (dialogueStateKeys.length - 1) ? ',' : ''}\n`; // Comma after dialogue state
          });
          entitiesString += `      }\n`; // Close dialogue object
          entitiesString += `    }${charIndex < (charsOnMap.length - 1) ? ',' : ''}\n`; // Comma after char object
        });
        entitiesString += `  ]${mapIndex < (mapKeys.length - 1) ? ',' : ''}\n`; // Comma after map array
      });
      entitiesString += `};`; // Close entities object

      exportedEntitiesOutput.value = entitiesString;
      exportedStateOutput.value = `const gameState = {\n  player: ${JSON.stringify(gameState.player, null, 2).replace(/\n/g, '\n  ')},\n  quests: ${JSON.stringify(gameState.quests, null, 2).replace(/\n/g, '\n  ')}\n};`;
    };


    // --- Data Getters ---

    const getSelectedEntity = () => {
      if (!selectedEntity) return null;
      return entities[selectedEntity.mapId]?.find(c => c.id === selectedEntity.charId);
    };

    const getSelectedDialogueState = () => {
      const char = getSelectedEntity();
      return char && selectedDialogueState ? char.dialogue[selectedDialogueState] : null;
    };

    const getSelectedDialogueOption = () => {
      const dialogueState = getSelectedDialogueState();
      return dialogueState && selectedDialogueOptionIndex !== null ? dialogueState.options[selectedDialogueOptionIndex] : null;
    };


    // --- Event Handlers ---

    const handleCanvasClick = (event) => {
      const rect = canvas.getBoundingClientRect();
      const x = Math.floor((event.clientX - rect.left) / TILE_SIZE);
      const y = Math.floor((event.clientY - rect.top) / TILE_SIZE);

      const charsOnMap = entities[currentMapId] || [];
      const clickedChar = charsOnMap.find(char => char.x === x && char.y === y);

      if (clickedChar) {
        selectedEntity = {
          mapId: currentMapId,
          charId: clickedChar.id
        };
        selectedDialogueState = Object.keys(clickedChar.dialogue)[0] || null;
        selectedDialogueOptionIndex = null;
        selectedActionIndex = null; // Clear action selection
      } else if (selectedEntity && selectedEntity.mapId === currentMapId) {
        // Move selected entity
        entities[currentMapId] = entities[currentMapId].map(char =>
          char.id === selectedEntity.charId ? {
            ...char,
            x,
            y
          } : char
        );
      } else {
        selectedEntity = null;
        selectedDialogueState = null;
        selectedDialogueOptionIndex = null;
        selectedActionIndex = null;
      }
      renderAllUI();
    };

    const handleEntityPropertyChange = (e) => {
      const {
        name,
        value
      } = e.target;
      const char = getSelectedEntity();
      if (!char) return;

      char[name] = (name === 'x' || name === 'y') ? parseInt(value) : value;
      renderAllUI();
    };

    const handleAddEntity = () => {
      showCustomModal("Enter new entity ID:", 'prompt', (newId) => {
        if (newId === null) return; // User clicked cancel
        if (!newId || (entities[currentMapId] || []).some(char => char.id === newId)) {
          showCustomModal("Invalid or duplicate ID.", 'alert');
          return;
        }
        const newChar = {
          id: newId,
          x: 0,
          y: 0,
          dialogue: {
            'start': {
              text: "Hello! I am a new entity.",
              options: []
            }
          }
        };
        entities[currentMapId] = [...(entities[currentMapId] || []), newChar];
        selectedEntity = {
          mapId: currentMapId,
          charId: newId
        };
        selectedDialogueState = 'start';
        selectedDialogueOptionIndex = null;
        selectedActionIndex = null;
        renderAllUI();
      }, generateUniqueId('entity')); // Default value for prompt
    };

    const handleDeleteEntity = () => {
      if (!selectedEntity) return;
      showCustomModal(`Are you sure you want to delete entity "${selectedEntity.charId}"?`, 'confirm', (result) => {
        if (result) {
          entities[currentMapId] = (entities[currentMapId] || []).filter(char => char.id !== selectedEntity.charId);
          selectedEntity = null;
          selectedDialogueState = null;
          selectedDialogueOptionIndex = null;
          selectedActionIndex = null;
          renderAllUI();
        }
      });
    };

    const handleDialogueTextChange = (e) => {
      const dialogueState = getSelectedDialogueState();
      if (!dialogueState) return;
      dialogueState.text = e.target.value;
      renderExportData();
    };

    const handleDialogueOptionChange = (e) => {
      const {
        name,
        value
      } = e.target;
      const option = getSelectedDialogueOption();
      if (!option) return;
      option[name] = value;
      renderExportData();
    };

    const handleAddDialogueState = () => {
      const char = getSelectedEntity();
      if (!char) return;
      showCustomModal("Enter new dialogue state ID:", 'prompt', (newStateId) => {
        if (newStateId === null) return;
        if (!newStateId || char.dialogue[newStateId]) {
          showCustomModal("Invalid or duplicate state ID.", 'alert');
          return;
        }
        char.dialogue[newStateId] = {
          text: `New state: ${newStateId}`,
          options: []
        };
        selectedDialogueState = newStateId;
        selectedDialogueOptionIndex = null;
        selectedActionIndex = null;
        renderAllUI();
      }, generateUniqueId('state'));
    };

    const handleDeleteDialogueState = () => {
      const char = getSelectedEntity();
      if (!char || !selectedDialogueState) return;
      showCustomModal(`Are you sure you want to delete dialogue state "${selectedDialogueState}"?`, 'confirm', (result) => {
        if (result) {
          delete char.dialogue[selectedDialogueState];
          selectedDialogueState = Object.keys(char.dialogue)[0] || null; // Select first state or null
          selectedDialogueOptionIndex = null;
          selectedActionIndex = null;
          renderAllUI();
        }
      });
    };

    const handleAddDialogueOption = () => {
      const dialogueState = getSelectedDialogueState();
      if (!dialogueState) return;
      dialogueState.options = [...(dialogueState.options || []), {
        text: "New option",
        nextState: "end",
        actions: []
      }];
      selectedDialogueOptionIndex = dialogueState.options.length - 1;
      selectedActionIndex = null;
      renderAllUI();
    };

    const handleAddActionToOption = () => {
      const option = getSelectedDialogueOption();
      if (!option) return;

      // Initialize with a default 'none' action, or first action in gameActionMetadata
      let defaultAction;
      const firstActionId = Object.keys(gameActionMetadata)[0];
      if (firstActionId) {
        defaultAction = {
          id: firstActionId,
          params: {}
        };
        const defaultActionMeta = gameActionMetadata[firstActionId];
        if (defaultActionMeta && defaultActionMeta.parameters) {
          defaultActionMeta.parameters.forEach(param => {
            if (param.defaultValue !== undefined) {
              defaultAction.params[param.name] = param.defaultValue;
            }
          });
        }
      } else {
        defaultAction = {
          id: 'none',
          params: {}
        }; // Fallback if gameActionMetadata is unexpectedly empty
      }

      option.actions = [...(option.actions || []), defaultAction];
      selectedActionIndex = option.actions.length - 1;
      renderDialogueOptionDetails(); // Re-render to show the new action's parameters
    };

    const handleDeleteDialogueOption = () => {
      const dialogueState = getSelectedDialogueState();
      if (!dialogueState || selectedDialogueOptionIndex === null) return;
      showCustomModal("Are you sure you want to delete this option?", 'confirm', (result) => {
        if (result) {
          dialogueState.options.splice(selectedDialogueOptionIndex, 1);
          selectedDialogueOptionIndex = null;
          selectedActionIndex = null;
          renderAllUI();
        }
      });
    };

    const handleAddQuest = () => {
      showCustomModal("Enter new quest ID:", 'prompt', (newQuestId) => {
        console.log("Adding new quest with ID:", newQuestId);
        if (newQuestId === null) return;
        if (!newQuestId || gameState.quests[newQuestId]) {
          showCustomModal("Invalid or duplicate ID.", 'alert');
          return;
        }
        gameState.quests[newQuestId] = 'not_started';
        renderQuestEditor();
        renderExportData(); // Update export data after adding quest
      }, generateUniqueId('quest'));
    };

    const handleMapChange = (mapId) => {
      currentMapId = mapId;
      selectedEntity = null; // Clear selection on map change
      selectedDialogueState = null;
      selectedDialogueOptionIndex = null;
      selectedActionIndex = null;
      renderAllUI();
    };

    // Master render function to update all UI parts
    const renderAllUI = () => {
      drawMap();
      renderMapSelector();
      renderEntityList();
      renderEntityDetails(); // This also calls renderDialogueEditor
      renderQuestEditor();
      renderExportData();
    };

    // --- Initialization ---
    document.addEventListener('DOMContentLoaded', () => {
      // Get DOM elements
      canvas = document.getElementById('gameCanvas');
      ctx = canvas.getContext('2d');
      charListDiv = document.getElementById('entity-list');
      addCharBtn = document.getElementById('add-entity-btn');
      deleteCharBtn = document.getElementById('delete-entity-btn');
      noCharSelectedMsg = document.getElementById('no-entity-selected-message');
      charDetailsPanel = document.getElementById('entity-details-panel');
      editingCharIdSpan = document.getElementById('editing-entity-id');
      charXInput = document.getElementById('entity-x-input');
      charYInput = document.getElementById('entity-y-input');
      dialogueStateSelect = document.getElementById('dialogue-state-select');
      addDialogueStateBtn = document.getElementById('add-dialogue-state-btn');
      deleteDialogueStateBtn = document.getElementById('delete-dialogue-state-btn');
      dialogueStateContentDiv = document.getElementById('dialogue-state-content');
      dialogueTextInput = document.getElementById('dialogue-text-input');
      testDialogueBtn = document.getElementById('test-dialogue-btn');
      dialogueOptionsList = document.getElementById('dialogue-options-list');
      addDialogueOptionBtn = document.getElementById('add-dialogue-option-btn');
      dialogueOptionContentDiv = document.getElementById('dialogue-option-content');
      editingOptionIndexSpan = document.getElementById('editing-option-index');
      optionTextInput = document.getElementById('option-text-input');
      optionNextStateInput = document.getElementById('option-next-state-input');

      // Elements for actions within an option
      actionsListDiv = document.getElementById('actions-list');
      addActionToOptionBtn = document.getElementById('add-action-to-option-btn');
      actionParametersSectionDiv = document.getElementById('action-parameters-section'); // New div for section
      editingActionIndexSpan = document.getElementById('editing-action-index');
      actionTypeSelect = document.getElementById('action-type-select');
      actionParametersDiv = document.getElementById('action-parameters');
      testActionBtn = document.getElementById('test-action-btn');
      deleteOptionBtn = document.getElementById('delete-option-btn');

      // Quests and Export
      questsListDiv = document.getElementById('quests-list');
      addQuestBtn = document.getElementById('add-quest-btn');
      exportedEntitiesOutput = document.getElementById('exported-entities-output');
      copyEntitiesBtn = document.getElementById('copy-entities-btn');
      exportedStateOutput = document.getElementById('exported-state-output');
      copyStateBtn = document.getElementById('copy-state-btn');

      // Set up event listeners
      canvas.addEventListener('click', handleCanvasClick);
      addCharBtn.addEventListener('click', handleAddEntity);
      deleteCharBtn.addEventListener('click', handleDeleteEntity);
      charXInput.addEventListener('change', handleEntityPropertyChange);
      charYInput.addEventListener('change', handleEntityPropertyChange);
      dialogueStateSelect.addEventListener('change', (e) => {
        selectedDialogueState = e.target.value;
        selectedDialogueOptionIndex = null; // Clear option selection on state change
        selectedActionIndex = null; // Clear action selection
        renderDialogueEditor();
      });
      addDialogueStateBtn.addEventListener('click', handleAddDialogueState);
      deleteDialogueStateBtn.addEventListener('click', handleDeleteDialogueState);
      dialogueTextInput.addEventListener('input', handleDialogueTextChange);
      testDialogueBtn.addEventListener('click', showDialogueSimulatorModal); // Now opens simulator
      addDialogueOptionBtn.addEventListener('click', handleAddDialogueOption);
      deleteOptionBtn.addEventListener('click', handleDeleteDialogueOption);
      optionTextInput.addEventListener('input', handleDialogueOptionChange);
      optionNextStateInput.addEventListener('input', handleDialogueOptionChange);

      addActionToOptionBtn.addEventListener('click', handleAddActionToOption);
      actionTypeSelect.addEventListener('change', updateCurrentActionParameters); // Update parameters based on selected action type
      testActionBtn.addEventListener('click', () => {
        const option = getSelectedDialogueOption();
        if (!option || selectedActionIndex === null) {
          showCustomModal("No action selected to test.", 'alert');
          return;
        }
        const actionObj = option.actions[selectedActionIndex];
        // Ensure actionObj is not null/undefined before proceeding
        if (!actionObj) {
          showCustomModal("No action selected to test (action object is null/undefined).", 'alert');
          return;
        }

        const actionDef = gameActionMetadata[actionObj.id];
        if (actionDef) {
          // Use a temporary game state for action testing outside of simulation modal
          let tempGameStateForTest = JSON.parse(JSON.stringify(gameState));
          let tempEntitiesForTest = JSON.parse(JSON.stringify(entities));
          try {
            if (actionObj.id === 'customAction') {
              // The custom action function expects (gameState, entities) as arguments
              const actionFunction = new Function('gameState', 'entities', actionObj.params.code);
              if (actionFunction) {
                actionFunction(tempGameStateForTest, tempEntitiesForTest);
                showCustomModal(`Custom action tested. Simulated state changes (check console): ${JSON.stringify(tempGameStateForTest.quests)}`, 'alert');
              }
            } else if (actionObj.id === 'none') {
              showCustomModal("No action selected (type 'None').", 'alert');
              return;
            } else {
              // Directly call the action function creator from the gameActions object
              const actionFunctionCreator = gameActions[actionObj.id];
              if (typeof actionFunctionCreator === 'function') {
                const orderedParams = actionDef.parameters.map(param => {
                  let val = actionObj.params[param.name];
                  // Ensure undefined/null values are handled, using default if available
                  if (val === undefined || val === null) {
                    return param.defaultValue !== undefined ? param.defaultValue : undefined;
                  }
                  return val;
                });
                const executableAction = actionFunctionCreator(...orderedParams);
                if (typeof executableAction === 'function') {
                  executableAction(tempGameStateForTest, tempEntitiesForTest, (c, s) => console.log(`[Test Action Dialogue]: ${c.dialogue[s].text}`));
                  showCustomModal(`Action tested. Simulated state changes (check console): ${JSON.stringify(tempGameStateForTest.quests)}`, 'alert');
                } else {
                  showCustomModal(`Error testing action: '${actionObj.id}' did not return an executable function. Check console.`, 'alert');
                }
              } else {
                showCustomModal(`Error testing action: Function '${actionObj.id}' not found in gameActions. Check console.`, 'alert');
              }
            }
          } catch (e) {
            console.error("Test Action Error:", e);
            showCustomModal(`Error testing action: ${e.message}. Check console.`, 'alert');
          }
        }
      });

      addQuestBtn.addEventListener('click', handleAddQuest);
      copyEntitiesBtn.addEventListener('click', () => copyToClipboard(exportedEntitiesOutput.value, 'entities.js content copied!'));
      copyStateBtn.addEventListener('click', () => copyToClipboard(exportedStateOutput.value, 'state.js content (quests only) copied!'));


      // Initial data setup and render
      initializeEditorData(); // Call this new initialization function
      renderAllUI();
    });

    // Ensure canvas redraws on window resize for responsiveness
    window.addEventListener('resize', () => {
      drawMap();
    });
  </script>
</body>

</html>