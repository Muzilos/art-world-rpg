<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>2D RPG Engine</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body {
            background-color: #1a202c;
            color: #e2e8f0;
            font-family: 'Courier New', Courier, monospace;
        }
        canvas {
            background-color: #2d3748;
            border: 2px solid #4a5568;
            border-radius: 0.5rem;
        }
        .dialogue-box {
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
        }
        .stats-panel {
            top: 20px;
            right: 20px;
        }
    </style>
</head>
<body class="flex flex-col items-center justify-center h-screen p-4">
    <h1 class="text-3xl font-bold mb-4">My RPG</h1>
    <canvas id="gameCanvas" width="800" height="600"></canvas>
    
    <!-- Dialogue Box -->
    <div id="dialogueBox" class="absolute dialogue-box w-11/12 md:w-3/4 bg-gray-800 border-2 border-gray-600 rounded-lg p-4 hidden">
        <p id="dialogueText" class="text-lg"></p>
        <div id="dialogueOptions" class="mt-4 flex flex-col space-y-2"></div>
        <button id="closeDialogue" class="mt-4 px-4 py-2 bg-blue-500 rounded hover:bg-blue-700 focus:outline-none focus:ring-2 focus:ring-blue-400 hidden">Close</button>
    </div>

    <!-- Stats Panel -->
    <div class="stats-panel absolute bg-gray-800 border-2 border-gray-600 rounded-lg p-4">
        <h2 class="text-xl font-bold mb-2">Player Stats</h2>
        <div id="statsContent">
            <p>Level: <span id="playerLevel">1</span></p>
            <p>HP: <span id="playerHP">100</span> / <span id="playerMaxHP">100</span></p>
            <p>Attack: <span id="playerAttack">10</span></p>
            <p>Defense: <span id="playerDefense">5</span></p>
            <p>XP: <span id="playerXP">0</span> / <span id="xpToNextLevel">100</span></p>
            <button id="levelUpButton" class="mt-4 px-4 py-2 bg-green-500 rounded hover:bg-green-700 hidden">Level Up!</button>
        </div>
    </div>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');

        const TILE_SIZE = 32;

        // --- Game State ---
        const gameState = {
            currentMap: 'town',
            player: {
                x: 5,
                y: 5,
                path: [],
                speed: 100, // Time in ms to move one tile. Lower is faster.
                moveTimer: 0, // Timer to track movement cooldown.
                stats: {
                    level: 1,
                    hp: 100,
                    maxHp: 100,
                    attack: 10,
                    defense: 5,
                    xp: 0,
                    xpToNextLevel: 100
                }
            },
            characters: {
                'town': [
                    { 
                        x: 8, y: 8, 
                        currentState: 'start', // Character's current dialogue state
                        dialogue: {
                            'start': {
                                text: "Hello, traveler! I seem to have lost my prized chicken. Could you help me find it?",
                                options: [
                                    { text: "Of course!", nextState: 'quest_accepted' },
                                    { text: "I'm too busy.", nextState: 'quest_rejected' }
                                ]
                            },
                            'quest_accepted': {
                                text: "Oh, thank you! I believe it wandered into the forest. Please be careful.",
                                options: [ { text: "I'll return soon.", nextState: 'end' } ]
                            },
                            'quest_rejected': {
                                text: "Oh, I see. Well, if you change your mind, you know where to find me.",
                                options: [ { text: "Goodbye.", nextState: 'end' } ]
                            },
                            'end': {
                                text: "Farewell.",
                                options: []
                            }
                        }
                    }
                ]
            }
        };

        // --- MAPS ---
        const maps = {
            'town': {
                width: 25,
                height: 19,
                tiles: [
                    // Create a border of walls (1) and a floor of grass (0)
                    1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
                    1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,
                    1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,
                    1,0,0,2,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,
                    1,0,0,2,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,
                    1,0,0,0,0,0,0,0,0,0,0,0,1,1,1,0,0,0,0,0,0,0,0,0,1,
                    1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,
                    1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,
                    1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,
                    1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,
                    1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,
                    1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,
                    1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,
                    1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,
                    1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,
                    1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,
                    1,0,0,0,0,0,0,0,0,0,0,0,3,0,0,0,0,0,0,0,0,0,0,0,1,
                    1,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,1,
                    1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
                ],
                transitions: [
                    { x: 12, y: 17, targetMap: 'forest', targetX: 12, targetY: 1 } 
                ]
            },
            'forest': {
                width: 25,
                height: 19,
                tiles: [
                    2,2,2,2,2,2,2,2,2,2,2,2,3,2,2,2,2,2,2,2,2,2,2,2,2,
                    2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,
                    2,0,0,2,2,0,0,0,0,2,0,0,0,0,0,0,0,2,2,0,0,0,0,0,2,
                    2,0,0,2,2,0,0,0,0,2,0,0,0,0,0,0,0,2,2,0,0,0,0,0,2,
                    2,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,
                    2,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,
                    2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,
                    2,2,2,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,2,2,2,
                    2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,
                    2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,
                    2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,
                    2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,
                    2,2,2,2,2,2,2,0,0,0,0,0,0,0,0,0,0,0,2,2,2,2,2,2,2,
                    2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,
                    2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,
                    2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,
                    2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,
                    2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,
                    2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2
                ],
                transitions: [
                    { x: 12, y: 0, targetMap: 'town', targetX: 12, targetY: 17 }
                ]
            }
        };

        const tileColors = {
            0: '#2f855a', // Grass
            1: '#718096', // Wall
            2: '#8b5cf6', // Flowers / Trees
            3: '#a0aec0', // Path
        };

        // --- A* Pathfinding ---
        function aStar(start, end, map) {
            const openSet = [{...start, g: 0, h: heuristic(start, end), f: heuristic(start, end)}];
            const closedSet = new Set();
            const cameFrom = {};

            while (openSet.length > 0) {
                openSet.sort((a, b) => a.f - b.f);
                let current = openSet.shift();

                if (current.x === end.x && current.y === end.y) {
                    return reconstructPath(cameFrom, current);
                }

                closedSet.add(`${current.x},${current.y}`);

                getNeighbors(current, map).forEach(neighbor => {
                    if (closedSet.has(`${neighbor.x},${neighbor.y}`)) {
                        return;
                    }
                    
                    const tentativeGScore = current.g + 1;

                    let neighborNode = openSet.find(n => n.x === neighbor.x && n.y === neighbor.y);
                    if (!neighborNode) {
                        neighborNode = {...neighbor, g: tentativeGScore, h: heuristic(neighbor, end), f: tentativeGScore + heuristic(neighbor, end)};
                        cameFrom[`${neighbor.x},${neighbor.y}`] = current;
                        openSet.push(neighborNode);
                    } else if (tentativeGScore < neighborNode.g) {
                         neighborNode.g = tentativeGScore;
                         neighborNode.f = tentativeGScore + neighborNode.h;
                         cameFrom[`${neighbor.x},${neighbor.y}`] = current;
                    }
                });
            }

            return []; // No path found
        }

        function heuristic(a, b) {
            // Manhattan distance
            return Math.abs(a.x - b.x) + Math.abs(a.y - b.y);
        }
        
        function getNeighbors(node, map) {
            const neighbors = [];
            const { x, y } = node;

            for (let dx = -1; dx <= 1; dx++) {
                for (let dy = -1; dy <= 1; dy++) {
                    if (dx === 0 && dy === 0) continue;

                    const newX = x + dx;
                    const newY = y + dy;

                    if (newX >= 0 && newX < map.width && newY >= 0 && newY < map.height) {
                         const tileIndex = newY * map.width + newX;
                         if(map.tiles[tileIndex] !== 1 && map.tiles[tileIndex] !== 2) { 
                            neighbors.push({ x: newX, y: newY });
                         }
                    }
                }
            }
            return neighbors;
        }

        function reconstructPath(cameFrom, current) {
            const totalPath = [current];
            while (cameFrom[`${current.x},${current.y}`]) {
                current = cameFrom[`${current.x},${current.y}`];
                totalPath.unshift(current);
            }
            return totalPath;
        }


        // --- Drawing ---
        function draw() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            const map = maps[gameState.currentMap];

            for (let y = 0; y < map.height; y++) {
                for (let x = 0; x < map.width; x++) {
                    const tileIndex = y * map.width + x;
                    ctx.fillStyle = tileColors[map.tiles[tileIndex]] || '#000';
                    ctx.fillRect(x * TILE_SIZE, y * TILE_SIZE, TILE_SIZE, TILE_SIZE);
                }
            }

            (gameState.characters[gameState.currentMap] || []).forEach(char => {
                ctx.fillStyle = 'purple';
                ctx.beginPath();
                ctx.arc(char.x * TILE_SIZE + TILE_SIZE / 2, char.y * TILE_SIZE + TILE_SIZE / 2, TILE_SIZE / 2 - 2, 0, Math.PI * 2);
                ctx.fill();
            });

            ctx.fillStyle = 'red';
            ctx.beginPath();
            ctx.arc(gameState.player.x * TILE_SIZE + TILE_SIZE / 2, gameState.player.y * TILE_SIZE + TILE_SIZE / 2, TILE_SIZE / 2 - 2, 0, Math.PI * 2);
            ctx.fill();
        }

        // --- Game Loop ---
        let lastTime = 0;
        function gameLoop(timestamp) {
            const deltaTime = timestamp - lastTime;
            lastTime = timestamp;

            update(deltaTime);
            draw();
            requestAnimationFrame(gameLoop);
        }

        function update(deltaTime) {
            gameState.player.moveTimer -= deltaTime;

            if (gameState.player.path.length > 0 && gameState.player.moveTimer <= 0) {
                gameState.player.moveTimer = gameState.player.speed;
                
                const nextStep = gameState.player.path.shift();
                gameState.player.x = nextStep.x;
                gameState.player.y = nextStep.y;
                
                // Transition check is now more robust.
                checkTransition();
            }
        }
        
        function checkTransition() {
            const map = maps[gameState.currentMap];
            const transition = map.transitions.find(t => t.x === gameState.player.x && t.y === gameState.player.y);

            if (transition) {
                gameState.currentMap = transition.targetMap;
                gameState.player.x = transition.targetX;
                gameState.player.y = transition.targetY;
                gameState.player.path = []; // Clear path after transition
            }
        }
        
        // --- UI & Interactions ---
        function updateStatsUI() {
            const stats = gameState.player.stats;
            document.getElementById('playerLevel').textContent = stats.level;
            document.getElementById('playerHP').textContent = stats.hp;
            document.getElementById('playerMaxHP').textContent = stats.maxHp;
            document.getElementById('playerAttack').textContent = stats.attack;
            document.getElementById('playerDefense').textContent = stats.defense;
            document.getElementById('playerXP').textContent = stats.xp;
            document.getElementById('xpToNextLevel').textContent = stats.xpToNextLevel;

            if (stats.xp >= stats.xpToNextLevel) {
                document.getElementById('levelUpButton').classList.remove('hidden');
            } else {
                 document.getElementById('levelUpButton').classList.add('hidden');
            }
        }

        function levelUp() {
            const stats = gameState.player.stats;
            if (stats.xp < stats.xpToNextLevel) return;

            stats.xp -= stats.xpToNextLevel;
            stats.level++;
            stats.xpToNextLevel = Math.floor(stats.xpToNextLevel * 1.5);
            stats.maxHp += 10;
            stats.hp = stats.maxHp;
            stats.attack += 2;
            stats.defense += 1;
            updateStatsUI();
        }

        document.getElementById('levelUpButton').addEventListener('click', levelUp);
        
        function showDialogue(character) {
            const dialogueNode = character.dialogue[character.currentState];
            if (!dialogueNode) {
                closeDialogue();
                return;
            }

            document.getElementById('dialogueText').textContent = dialogueNode.text;
            const optionsContainer = document.getElementById('dialogueOptions');
            const closeButton = document.getElementById('closeDialogue');
            
            // Clear previous options
            optionsContainer.innerHTML = '';

            if (dialogueNode.options && dialogueNode.options.length > 0) {
                closeButton.classList.add('hidden');
                dialogueNode.options.forEach(option => {
                    const button = document.createElement('button');
                    button.textContent = option.text;
                    button.className = 'px-4 py-2 bg-gray-600 rounded hover:bg-gray-700 focus:outline-none focus:ring-2 focus:ring-gray-500';
                    button.onclick = () => {
                        character.currentState = option.nextState;
                        // If the next state is 'end', reset to start for next interaction
                        if(option.nextState === 'end') {
                            character.currentState = 'start';
                            closeDialogue();
                        } else {
                           showDialogue(character);
                        }
                    };
                    optionsContainer.appendChild(button);
                });
            } else {
                 // No options, so show the default close button
                 closeButton.classList.remove('hidden');
            }
            
            document.getElementById('dialogueBox').classList.remove('hidden');
        }

        function closeDialogue() {
            document.getElementById('dialogueBox').classList.add('hidden');
        }
        
        document.getElementById('closeDialogue').addEventListener('click', closeDialogue);

        canvas.addEventListener('click', (event) => {
            // Don't register clicks if a dialogue is open.
            if (!document.getElementById('dialogueBox').classList.contains('hidden')) {
                return;
            }

            const rect = canvas.getBoundingClientRect();
            const mouseX = event.clientX - rect.left;
            const mouseY = event.clientY - rect.top;

            const tileX = Math.floor(mouseX / TILE_SIZE);
            const tileY = Math.floor(mouseY / TILE_SIZE);

            // Check for character interaction first
            const character = (gameState.characters[gameState.currentMap] || []).find(c => c.x === tileX && c.y === tileY);
            if (character) {
                showDialogue(character);
                return;
            }
            
            // If no character, calculate path for player movement
            const map = maps[gameState.currentMap];
            const path = aStar({ x: gameState.player.x, y: gameState.player.y }, { x: tileX, y: tileY }, map);
            
            if (path.length > 0) {
                path.shift(); 
                gameState.player.path = path;
                gameState.player.moveTimer = 0;
            }
        });

        // --- Initial Setup ---
        updateStatsUI();
        requestAnimationFrame(gameLoop);
    </script>
</body>
</html>
